using System;

namespace FTT
{
    #region TrimmedPattern structure

    /// <summary>Represents a pattern: seed word and his frequency.</summary>
    public struct TrimmedPattern : IComparable
    {
        /// <summary>The serial number of pattern's seed word in the total words sequence.</summary>
        public int SeedNumber;
        /// <summary>The frequency of the pattern with mismatches.</summary>
        public int Freq;
        /// <summary>The average of the pattern.</summary>
        public Average Avrg;

        /// <summary>Compares by default the current instance with another Pattern by Frequency;
        /// descending order.</summary>
        /// <param name="obj">The compared Pattern</param>
        /// <returns>1 if obj Frequency is more; -1 if obj Frequency is less; 0 if both are equal.</returns>
        int IComparable.CompareTo(object obj)
        {
            return Math.Sign(((TrimmedPattern)obj).Freq - Freq);
        }

        /// <summary>Outputs this instance.</summary>
        /// <param name="isF">Value indicated if should to output F</param>
        /// <param name="isAvrg">Value indicated if should to output Average</param>
        /// <returns></returns>
        public string ToString(bool isF, bool isAvrg)
        {
            string res = String.Format("{0} {1,5}", Words.WordToString(SeedNumber, false), Freq.ToString());
            if (isF)
            {
                res += String.Format(" {0,5:N1}", Avrg.F(Freq));    // F value
                if (isAvrg)
                    res += String.Format(" {0,7:0.0} {1,5:.0}", Avrg.Mean, Avrg.SD); // mean & SD values
            }
            return res;
        }
    }

    #endregion

    /// <summary>Represents a collection of patterns and their average and FF.</summary>
    public class TrimmedPatterns : StructArray<TrimmedPattern>
    {
        Patterns _initPtns;
        private int _realCount = 0;

        /// <summary>Initializes a new instance of the TrimmedPatterns class.</summary>
        /// <param name="worker">The BackgroundWorker in wich Processing is run.</param>
        /// <param name="shakeCnt">The amount of shakes.</param>
        /// <param name="isAvrgIndividual">True if the Individual Average Choice mode is set; otherwise, false.</param>
        /// <param name="stepCntOnShake">The number of progress bar steps generated by method within one shake; 0 if without progress bar steps.</param>
        /// <param name="isDrawPlot">True if a plot should be drawing; otherwise, false.</param>
        /// <returns></returns>
        public TrimmedPatterns(System.ComponentModel.BackgroundWorker worker, short shakeCnt, bool isAvrgIndividual, float stepCntOnShake, bool isDrawPlot)
            : base(Words.Count, NON_SORT)
        {
            _realCount = _coll.Length;
            Average[] avrgs = isAvrgIndividual ? null : new Average[1];
            TrimmedPattern tPtn;
            int maxFreqNumber = 0;      // not used in this case
            OnPrgBarReseat();
            // final drawing is been executed in invoking method, so we shold draw intermediate shakes only
            _initPtns = Patterns.GetTreatedPatterns(
                worker, 0, Sequence.Length, shakeCnt,
                ref avrgs, 
                ref maxFreqNumber, stepCntOnShake, isDrawPlot);
            int k = isAvrgIndividual ? 1 : 0;
            for (int i = 0; i < _initPtns.Count; i++)
            {
                tPtn.SeedNumber = i;
                tPtn.Freq = _initPtns[i];
                tPtn.Avrg = avrgs[k * i];
                this[i] = tPtn;
            }
            worker.ReportProgress(Patterns.TreatSORTING);
            Shrink();
        }

        /// <summary>Gets the number of unzero patterns.</summary>
        public new int Count    { get { return _realCount; } }

        /// <summary>Patterns of this instance.</summary>
        public Patterns Patterns    { get { return _initPtns; } }

        /// <summary>Removes all the elements with the zero Frequency from the instance.</summary>
        /// <remarks>Sorts the collection by Frequency.</remarks>
        void Shrink()
        {
            Sort();
            for (int i = 0; i < _coll.Length; i++)
                if (this[i].Freq == 0)
                {
                    // avoid to allocate new memory
                    //Array.Resize(ref _coll, _realCount = i);
                    _realCount = i;
                    break;
                }
        }

        /// <summary>Reports the shrinked (without zero Frequency) Similars of the specified pattern.</summary>
        /// <param name="seedNumber">The number of the seed-word.</param>
        /// <returns>If Similars have zero-frequency items, the shrinked (without zero Frequency) Similars; otherwise initial Similars.</returns>
        public Similars GetSimilars(int seedNumber)
        {
            Similars smls = Similars.GetSimilars(seedNumber);
            bool isNotCopied = true;

            // We have to remove from the total Similars all the numbers with zero Frequency
            int j;
            bool isFound = true;
            for (int i = 0; i < smls.Count; i++)
            {
                // scan throw the whole collection to check for real existing similars
                for (j = 0; j < Count; j++)
                    if (isFound = this[j].SeedNumber == smls[i])
                        break;
                if (!isFound)
                {
                    // if zero-frequence element is finded, Similars should be copied
                    // because it change its Count by shrinking
                    if (isNotCopied)
                    {
                        smls = smls.Copy();
                        isNotCopied = false;
                    }
                    smls[i] = Similars.UndefNumber;
                }
            }
            return isNotCopied ? smls : smls.Shrink();
        }

        /// <summary>Gets the amount of memory required for one element of collection.</summary>
        /// <returns>The maximum number of bytes of memory required for one element of collection.</returns>
        public static int OneSize   ()
        {
            return System.Runtime.InteropServices.Marshal.SizeOf(new TrimmedPattern());
        }

        public string GetCaption(bool isShake, byte visibleSimilarsCnt, bool isAvrgIndividual)
        {
            string res;

            res = Words.WordLength < Abbr.Pattern.Length - 2 ? Abbr.Patt : Abbr.Pattern;
            // right-align the title 'Pattern' to the right margin of : names
            if (Words.WordLength > Abbr.Pattern.Length)
                res = res.PadLeft(Words.WordLength);
            res += string.Format(" {0}", Abbr.Freq);
            if (isShake) res += string.Format(" {0,3}", Abbr.F);
            if (isAvrgIndividual && isShake)
                res += string.Format(" {0,7} {1,4}", Abbr.Mean, Abbr.SD);
            if (visibleSimilarsCnt > 0) res += string.Format(" {0,5}", Abbr.CV);

            return res;
        }

        /// <summary>
        /// Prints treated patterns and theys calculating results to formatted strings array.
        /// </summary>
        /// <param name="isShake">The value indicates if sheking is on.</param>
        /// <param name="visibleSimilarsCnt">The amount if visible Similars.</param>
        /// <param name="isAvrgIndividual">True if List Averaging Choice is an Individual.</param>
        /// <returns></returns>
        public string[] ToStrings(bool isShake, byte visibleSimilarsCnt, bool isAvrgIndividual)
        {
            byte factor = 0;    // 0 if no similars, otherwise 1
            bool isMotifs = visibleSimilarsCnt > 0;
            int cnt = isMotifs ? visibleSimilarsCnt << (factor = 1) : Count;
            string[] strs = new string[cnt + 1];

            // set data
            Similars smls;
            TrimmedPattern tp;
            for (int i = 0; i < cnt; i++)
            {
                tp = this[i >> factor];
                strs[i] = tp.ToString(isShake, isAvrgIndividual);
                if (isMotifs)
                {
                    smls = GetSimilars(tp.SeedNumber);
                    strs[i] += String.Format(" {0,4:0.0}", smls.GetCV(0, Sequence.Length, tp.SeedNumber));  // CV
                    strs[++i] = smls.ToString();  // outputs a set of string with 'words' printed Red
                }
            }
            return strs;
        }
    }
}
